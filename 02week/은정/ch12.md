# 핵심 내용 정리

## 12.1 함수란?

- `함수` : 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- `매개변수` : 함수 내부로 입력을 전달받는 변수

## 12.2 함수를 사용하는 이유

- 코드 중복을 억제하고, 재사용성을 높임
    
    ⇒ 유지보수의 편의성, 코드의 신뢰성
    
- 코드의 가독성

## 12.3 함수 리터럴

- 구성 요소
    - 함수 이름 : 기명함수(이름이 있는 함수) / 익명함수(이름이 없는 함수)
    - 매개변수 목록
    - 함수 몸체
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.

## 12.4 함수 정의

### 12.4.1 함수 선언문

```jsx
function add(x,y) {
	return x + y;
}
```

- 함수 이름을 생략할 수 없다.
- **표현식이 아닌 문**
- 자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

### 12.4.2 함수 표현식

- 자바스크립트의 함수는 일급 객체이다.
    - `일급 객체` : 값의 성질을 갖는 객체
    
    ⇒ 함수를 값처럼 자유롭게 사용할 수 있다.
    
    ⇒ 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. : `함수 표현식`
    
- **표현식인 문**

### 12.4.3 함수 생성 시점과 함수 호이스팅

- `함수 선언문` : 함수 선언문 이전에 호출 가능
- `함수 표현식` : 함수 선언문 이전에 호출 불가능

← **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문**

- `함수 호이스팅` : 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
- 함수 호이스팅과 변수 호이스팅
    - **유사점** : var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 먼저 실행되어 식별자를 생성한다
    - **차이점** :
        - **변수와 함수 선언문 :** 변수의 경우 undefined로 초기화되고, 함수 선언문을 통해 생성된 식별자는 함수 객체로 초기화된다.
        - **변수와 함수 표현식 :**  변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만, **변수 할당문의 값은 런타임에 평가되므로 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**
            
            ← 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 표현과 동일하게 동작하기 때문
            
            ⇒ **함수 표현식으로 함수를 정의할 경우 변수 호이스팅이 발생한다.**
            

### 12.4.4 화살표 함수

- 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화됨
- 생성자 함수로 사용 불가능, 기존 함수와 this 바인딩 방식이 다름, prototype 프로퍼티 없음, argument 객체를 생성하지 않음

## 12.5 함수 호출

### 12.5.1 매개변수와 인수

- 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.
    
    ⇒ 매개변수의 스코프(유효 범위)는 함수 내부
    
- 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.
    
    ⇒ 가변 인자 함수(매개변수를 확정할 수 없는 함수)를 구현할 때 유용하게 사용됨
    

### 12.5.2 인수 확인

- 함수 내부에 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출을 사전에 방지할 수 없고 에러는 런타임에 발생하게 된다.
    
    ⇒ 방지 방법
    
    1. 타입스크립트(자바스크립트의 상위 확장) 도입 ⇒ 컴파일 시점의 부적절한 호출 방지
    2. arguments 객체를 통한 인수 개수 확인
    3. 인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당

### 12.5.3 매개변수의 최대 개수

- 이상적인 함수는 한 가지 일만 해야하며 가급적 작게 만들어야한다.
    
    ← 매개 변수의 개수가 많다는 것은 함수가 여러 가지 일을 한다는 증거이기 때문
    
    ⇒ 최대 3개 이상을 넘지 않는 것을 권장. 그 이상이 필요하다면 객체로 전달하기
    
- 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과가 발생한다.

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 원시 타입 인수 : 값을 변경(재할당을 통한 교체)하더라도 원본은 훼손되지 않음
    
    ⇒ 어떠한 부수효과도 발생하지 않음
    
- 객체 타입 인수 : 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손됨
    
    ⇒ 부수효과 발생
    

⇒ 객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다

- `옵저버 패턴(Observer Pattern)` : 옵저버(관찰자)들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 직접 목록의 각 관찰자들에게 통지하고, 관찰자들은 알림을 받아 조치를 취하는 행동 패턴

⇒ 해결 방법 중 하나 : 객체를 불변 객체로 만들어 사용하는 것 (객체의 방어적 복사인 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체)

⇒ 부수 효과를 없앨 수 있음

- `순수 함수` : 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수
    
    → `함수형 프로그래밍` : 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 프로그래밍 패러다임
    

## 12.7 다양한 함수의 형태

### 12.7.1 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 함수
- 단 한 번만 호출되며 다시 호출할 수 없음
- 반드시 그룹 연산자 `(…)` 로 감싸야 함
    
    ← 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해
    
- 즉시 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있음

### 12.7.2 재귀함수

- `재귀 호출` : 함수가 자기 자신을 호출하는 것
- `재귀 함수` : 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수
- 반복되는 처리를 반복문 없이 구현할 수 있음. 단, 재귀 호출을 멈출 수 없는 **탈출 조건**이 필수
    
    → 탈출 조건이 없으면 함수가 무한 호출되어 스택 오버플로 에러가 발생
    

### 12.7.4 콜백 함수

- `콜백 함수` : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- `고차 함수` : 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
    
    → 콜백 함수를 자신의 일부분으로 합성
    
- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
    
    ⇒ 콜백 함수는 고차 함수에 의해 호출되며 이때 고차함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.
    
- 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차함수에 전달하는 것이 일반적.
    
    ```jsx
    repeat(5, function (i) {
    	if (i % 2) console.log(i);
    }); // 1 3
    ```
    
    그러나 콜백 함수를 다른 곳에서 호출할 필요가 있거나, 콜백 함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 전달하는 편이 효율적임
    

### 12.7.5 순수 함수와 비순수 함수

- `순수 함수` : 부수효과가 없는 함수
    1. 외부 상태에 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환값을 만듦.
    2. 함수의 외부 상태를 변경하지 않음
- `비순수 함수` : 부수 효과가 있는 함수
    1. 외부 상태에 따라 반환값이 달라짐
    2. 함수의 외부 상태를 변경함(부수 효과가 있음)
- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다.
    
    ⇒ 순수 함수를 사용하는 것이 좋음
    
    ⇒ `함수형 프로그래밍` : 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
    

---

# 면접 예상 질문

## 💥 함수선언문과 함수표현식의 차이?

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.

그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

이는 **함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문**이다.

`함수 선언문`의 경우 미리 메모리에 등록되기 때문에, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 되는 것이다.

`함수 표현식`은 함수를 **변수에 할당하기 때문에,** 런타임 이전에 undefined로 초기화되고, 런타임 시점에 함수가 할당되어 작동된다.

## 💥 함수 호이스팅이란?

함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업이다.

## 💥 함수 호이스팅과 변수 호이스팅의 차이?

var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 먼저 실행되어 식별자를 생성한다는 점에서 동일하다.

그러나 변수의 경우 undefined로 초기화되고, 함수 선언문을 통해 생성된 식별자는 함수 객체로 초기화된다.

함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 표현과 동일하게 동작하므로, 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만, **변수 할당문의 값은 런타임에 평가되므로 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.**

따라서 **함수 표현식으로 함수를 정의할 경우 변수 호이스팅이 발생한다.**

## 💥 기존함수와 화살표 함수의 차이

화살표 함수는 function 키워드 대신 화살표를 사용해 간략하게 함수를 선언한 함수이다.

화살표 함수는 기존 함수와 달리

1. 생성자 함수로 사용할 수 없으며
2. 기존 함수와 this 바인딩 방식이 다르고
3. prototype 프로퍼티가 없으며
4. argument 객체를 생성하지 않는다.

## 💥 기존함수와 화살표 함수의 this 바인딩 차이

this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.

일반 함수의 this는 함수가 어떻게 호출되느냐에 따라 동적으로 결정되지만,

화살표 함수의 this는 상위 스코프의 this를 그대로 따르기 때문에 함수 자체의 바인딩을 갖지 않는다.

때문에 화살표 함수는 별도의 작업을 추가로 하지 않고 this를 접근할 수 있다는 특징이 있다.

---

# 이야기하고 싶은 것

### p.168

> 화살표 함수는 기존 함수와 달리 this 바인딩 방식이 다르고 … →
> 
> 
> ## 💥 기존함수와 화살표 함수의 this 바인딩 차이
> 
> this는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값이다.
> 
> 일반 함수의 this는 함수가 어떻게 호출되느냐에 따라 동적으로 결정되지만,
> 
> 화살표 함수의 this는 상위 스코프의 this를 그대로 따르기 때문에 함수 자체의 바인딩을 갖지 않는다.
> 
> 때문에 화살표 함수는 별도의 작업을 추가로 하지 않고 this를 접근할 수 있다는 특징이 있다.
> 

개념 이해가 어려움. 다 같이 한 번 더 이야기하면서 이해하면 좋을 것 같음. 

### p.177

> 객체의 변경을 추적하려면 옵저버 패턴 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다
> 
> - `옵저버 패턴(Observer Pattern)` : 옵저버(관찰자)들이 관찰하고 있는 대상자의 상태가 변화가 있을 때마다 대상자는 직접 목록의 각 관찰자들에게 통지하고, 관찰자들은 알림을 받아 조치를 취하는 행동 패턴
> 
> ⇒ 해결 방법 중 하나 : 객체를 불변 객체로 만들어 사용하는 것 (객체의 방어적 복사를 통해 깊은 복사를 진행해 새로운 객체를 생성하고 재할당을 통해 교체)
> 
> ⇒ 부수 효과를 없앨 수 있음
> 

복사본을 만들고 원본 대신 복사본을 변경하는 ‘카피-온-라이트’가 생각났음.

같은 개념이라고 생각했는데 둘이 비슷한 듯 다른 개념이라, 카피-온-라이트와 방어적 복사를 비교하고 이야기해보고자 함.

### p.184

> `콜백 함수` : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
> 
> 
> `고차 함수` : 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
> 
> → 콜백 함수를 자신의 일부분으로 합성
> 
> 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
> 
> ⇒ 콜백 함수는 고차 함수에 의해 호출되며 이때 고차함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.
> 

고차 함수… 개념이 한 번에 이해하기엔 어려웠음.