# 함수

## 12.1 함수란?

- 함수 : 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행단위로 정의한 것
- 함수는 값이며 여러개 존재할 수 있다.
- 용어 정리

  - 매개변수 : 함수 내부로 입력을 전달받는것
  - 인수 : 입력
  - 반환값 : 출력
  - 함수이름 : 함수 구분 식별자 (함수 여러개 존재하기 때문에 식별자가 필요하다)
  - 함수 정의 : 정의를 통해 함수 생성

    - 함수선언문, 함수 표현식, Function 생성자 함수, 화살표 함수

  - 함수호출 : 함수가 실행됨. 코드 블록에 담긴 문들이 일괄적으로 실행하고 실행결과인 반환값을 반환함

## 12.2 함수를 사용하는 이유

- 코드의 재사용 : 여러번 함수 호출 시 재사용성 높음

  - 코드 중복을 억제
  - 유지보수 편의성 높임
  - 코드의 신뢰성 향상

- 코드 가독성 향상
  - 코드는 개발자를 위한 문서이므로 함수 이름은 가독성있게 지어야 한다.
    - 함수는 객체 타입의 값이다. > 식별자 붙이기 가능

## 12.3 함수 리터럴

- 함수는 객체 타입의 값이다. > 함수 리터럴로 함수 생성 가능
  - 구성
    - function 키워드
    - 함수이름
      - 식별자 네이밍 규칙 준수
      - 함수 몸체내에서만 참조할 수 있음
      - 생략 가능 = 익명함수 ( 이름이 있으면 기명함수 )
    - 매개변수목록
      - 0개 이상의 매개변수 존재, 쉼표구분
      - 순서가 중요 : 함수 호출시 지정한 인수가 순서대로 할당
      - 함수 몸체에서는 변수와 동일하게 취급 > 식별자네이밍규칙 준수
    - 함수 몸체
      - 함수 호출시 일괄적으로 실행될 문을 실행단위로 정의한 코드 블록
      - 함수 호출시에 실행
- 변수 할당 가능 : 함수 리터럴을 변수에 할당함
  ```js
  const func = function (x, y) {
    return x + y;
  };
  ```
  - 리터럴은 값을 생성하기 위한 표기법 > 생성된 값은 객체 > 함수는 객체
  - 그러나 일반객체와 다름 :
    - 일반객체는 호출 불가능, 함수는 가능
    - 함수객체만의 고유 프로퍼티 있음

## 12.4 함수 정의

- 호출하기 이전에 인수를 전달받을때 매개변수, 실행할문, 반환할 값 지정하는 것
- 정의된 함수가 자바스크립트 엔진에 의해 평가되서 함수 객체가 됨
- 변수 선언과 함수 정의 :
  - 변수는 선언
  - 함수는 정의 : 함수 선언문 평가시 식별자가 암묵적으로 생성되고 함수 객체가 할당됨
- 정의 방법

  - 함수선언문
    ```js
    function add(x, y) {
      return x + y;
    }
    console.dir(add); // f add(x,y) 함수 객체 프로퍼티까지 출력
    console.log(add); // ƒ add(x, y) { return x + y; } 함수 전체 출력
    console.log(add(1, 2)); // 3
    ```
    - 표현식이 아닌 문 : 따라서 위 함수 선언문 자체를 콘솔로그에 찍으면 undefined 나옴. 표현식이라면 값이 나와야함. > 즉 변수 할당이 불가능
    - 함수리터럴과 형태 동일, 단 이름 생략 안됨 (함수 리터럴은 이름생략 가능)
      - 그러나!!!! 아래와 같이 할당이 되어 보이는 이유는 기명함수 리터럴이 중의적인 표현이기 때문.
        ```js
        var add = function add(x, y) {
          return x + y;
        };
        ```
      - 자바스크립트 엔진에서 밑에 선언문을 함수 리터럴 표현식으로 해석</br>=> 문맥에 따라 중의적으로 해석함.
      - 중의적 표현 예시
        - ex) {} 중괄호 : 블록문 or 객체 리터럴
        - ex) 기명함수 : 함수 선언문(표현식X) or 함수 리터럴 (표현식 O)
      - 기명함수의 중의적 표현으로 인해 함수 생성되는 것은 동일하나 생성하는 내부 동작에 차이가 있음
        - `(function add(x, y) { return x + y;})` : () 그룹 연산자 안에 함수리터럴 입력 시 선언문으로 해석X, 리터럴표현으로 해석 <br/> => 그룹연산자안에는 값으로 평가가능한 표현식이어야함.
      - 호출 차이 : 리터럴로 생성된 식별자는 호출 불가능 / 함수선언문으로 생성된 식별자 호출 가능
        - 리터럴 : 함수이름은 함수 몸체에서만 참조 가능 따라서 함수리터럴로 생성됨 함수에서는 함수이름으로 호출 불가능하다.
        - 함수선언문 : 함수 이름을 암묵적으로 식별자로 생성함
          - 자바스크립트 엔진이 선언문 해석하여 함수객체 생성 > 함수이름은 몸체내부에서만 유효한 식별자로 이름과 별도로 함수객체를 가리키는 식별자가 필요(식별자가 없으면 함수객체 참조나 호출이 불가능) > 암묵적으로 함수이름과 동일한 식별자 생성하고 함수 객체 할당
          - 함수이름(addName)으로 호출하는것이 아닌 함수 객체를 가리키는 식별자(add)로 호출
            `var add = function addName() {~~}`
    - 정리 :: 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 생각.. (동작이 동일하지는 않음)
  - 함수 표현식 (권장)

    ```js
    var add = function (x, y) {
      return x + y;
    };
    ```

    - 표현식인 문
    - 일급객체 : 값처럼 변수 할당, 프로퍼티 값 가능, 배열의 요소도 가능 등 값의 성질을 갖는 객체
    - 함수는 일급객체임으로 리터럴로 생성한 함수 객체를 변수에 할당 가능 => 이렇게 하는게 함수 표현식
    - 함수 리터럴의 함수 이름은 생략 가능 = 익명함수 (함수표현식의 이름은 생략 안됨)
    - 함수 생성 시점과 함수 호이스팅(변수호이스팅과 다름) : 함수의 생성시점이 달라 아래와 같은 차이 발생
      - 함수선언문으로 정의한 함수 : 선언문 이전에 호출 가능</br>
        => 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행됨 즉 런타임 이전에 함수 객체가 먼저 생성되고, 함수이름과 동일한 식별자를 암묵적으로 생성하여 함수 객체를 할당함. </br>따라서 런타임에는 이미 생성된 함수를 참조할 수 있다.
      - 함수표현식으로 정의한 함수 : 표현식 이전에 호출 불가능
      * 변수 호이스팅과 비교 :
        - 동일 : 런타임 이전에 식별자를 생성
        - 차이 :
          - var 변수 : undefined로 초기화, 선언 전에 참조 시 undefined 반환
          - 함수 표현식 : 함수 객체로 초기화, 선언전 호출 시 호출 가능</br>
            - 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 됨
            - 함수 표현식으로 함수 정의시 변수 호이스팅이 발생함. 표현식은 변수에 할당한것이기 때문 > undefined 가 나오면서 타입에러뜸
              따라서 반드시 표현식 이후에 참조 또는 호출해야함.

  - Function 생성자 함수
    ```js
    var add = new Function("x", "y", "return x + y");
    ```
    - 생성자 함수 : 객체를 생성하는 함수
    - 함수선언문, 함수표현식과 다르게 동작 : 클로저를 생성하지 않음
  - 화살표 함수(es6)
    ```js
    var add = (x, y) => x + y;
    ```
    - 표현, 내부동작 모두 간략화
    - 익명함수로 정의
    - 생성자함수로 사용 X, this 바인딩 방식 다름, prototype 프로퍼티 없음, arguments 객체 미 생성

## 12.5 함수 호출

- `var result = add(1, 2)`
- 식별자 + () 로 호출
- 0개 이상의 인수를 쉼표로 구분
- 호출 시 현재 실행흐름 중단 후 함수로 실행흐름을 옮김
- 매개변수와 인수
  - 매개변수 : 함수 실행을 위해 필요한 값을 외부에서 내부로 전달하는것.
    - 함수 내에서 변수와 동일하게 취급 : 함수 호출 될떄마다 암묵적으로 매개변수가 생성 > undefined로 초기화 후 인수 할당
    - 스코프는 함수 내부
  - 인수 : 값으로 평가될수 있는 표현식으로 구성. 호출시 지정하며 개수와 타입 제한없음.
    매개변수를 통해 인수를 전달.
    - 인수가 부족해도 에러 X. 할당되지 않은 매개변수는 undefined(초기화된값 할당이 안된 상태)
    - 인수가 많으면 에러X : 초과된 인수 무시되고 암묵적으로 arguments객체의 프로퍼티로 보관
      - argument : 매개변수 개수를 확정할수 없는 가변 인자 함수 구현시 사용
- 인수 확인
  - 함수 정의 시 적절한 인수가 전달되었는지 확인 필요 : 개수 체크 안함, 매개변수 타입을 사전에 지정 불가능
    ```js
    var add = function (x = 0, y = 0) {
      // 따라서 인수의 기본값 지정
      return x + y;
    };
    ```
- 매개변수의 최대 개수
  - 적을 수록 좋음
  - 함수가 한가지 일을 하도록 3개 이하로 지정
- 반환문

  - return + 표현식(반환값) 으로 이루어진 반환문으로 실행결과를 외부로 반환함
  - 함수 호출(표현식)은 반환값으로 평가됨
  - 반환문 역할
    - 함수 실행 중단 후 빠져나감
    - return 뒤에 오는 표현식을 평가해 반환 없으면 undefined가 반환됨
  - 반환문 생략 가능(undefined 반환)
  - return 문 밑의 코드는 무시됨
  - 반환문은 몸체 내부에서만 사용 (전역사용X)

    - Node.js는 모듈 시스템에 의해 독립적인 파일 스코프가 있어서 파일의 가장 바깥영역에 반환문 사용해도 에러X

## 12.6 참조에 의한 전달과 외부 상태의 변경

- 원시값은 값에 의한 전달, 객체는 참조에 의한 전달로 동작.
- 매개변수도 타입에 따라 값의 전달방식이 두가지. 그러나 동작방식 똑같음

  - 값에 의한 호출 : 원본값 그대로 복사되어 부수효과 X
    - 함수 몸체에서 변경하지만 원시값은 변경불가능함으로 재할당으로 새로운 원시값을 교체함
  - 참조에 의한 호출 : 객체타입값 변경됨 부수효과 O

    - 객체값은 변경가능한 값으로 함수 몸체에서 변경 시 재할당 없이 직접 할당된 객체를 변경함
    - 객체 변경을 추적하려면 옵저버 패턴 등으로 방지가능, 추가로 객체를 불변객체로 만들수도 있음 => 깊은 복사

## 12.7 다양한 함수의 형태

- 즉시실행함수 : 정의와 동시에 즉시 호출되는 함수. 단 한번만 호출
  ```js
  (function () {
    console.log("hi");
  })();
  ```
  - 보통 익명함수, 기명 즉시 실행 함수도 가능하지만 ()그룹연산자 내의 기명함수는 선언문이 아닌 리터럴로 평가됨 다시 호출 불가능
  - 반드시 ()그룹 연산자로 감싸야함 안그러면 에러 발생
    - 에러 원인은 함수 정의가 함수 선언문의 형식과 다르기 때문 : 함수 이름 생략 불가능
    - ()그룹 연산자로 감싸면 함수 리터럴을 평가해서 함수 객체를 생성함
  - 일반 함수처럼 값 반환하, 인수 전달 가능
  - 변수 함수 이름의 충돌 방지 가능
- 재귀 함수 : 재귀 호출을 수행하는 함수 (보통 반복 처리때 사용)
  ```js
  function conutdown(n) {
    if (n < 0) return;
    console.log(n);
    countdown(n - 1); // 재귀 호출
  }
  conutdown(10); // 10,9,8... 반복문 없이 구현 가능
  ```
  - 재귀 호출 : 자기자신을 호출하는것 (식별자로 호출 : 내부에서 식별자, 이름 모두 호출가능/ 단 외부에서는 식별자로만 호출!)
  - 무한 재귀 호출로 인해 탈출조건 반드시 필요!
- 중첩 함수(=내부함수) : 함수 내부에 정의된 함수, 외부 함수 내부에서만 호출 가능 보통 외부함수를 돕는 헬퍼함수의 역할을 함
  - 외부함수 : 중첩함수 포함하는 함수
  ```js
  function outer() {
    var x = 1;
    // 중첩함수
    function inner() {
      var y = 2;
      // 외부 함수의 변수 참조 가능
      console.log(x + y);
    }
    inner();
  }
  outer();
  ```
  - if문 for문 블록에서 함수 정의 권장X > 호이스팅문제
  - 클로저와도 관련있음
- 콜백 함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수

  - 고차함수 : 매개변수를 통해 함수의 외부에서 콜백함수를 전달받은 함수
    => 콜백함수가 고차함수에 전달되어 헬퍼 함수의 역할을 함, 단 중첩은 고정되어있고 콜백함수는 고차함수 내부로 주입하기 때문에 자유롭게 교체가능 : 고차함수는 콜백함수를 자신의 일부분으로 합성
  - 고차함수는 매개변수를 통해 전달받은 콜백함수의 호출시점을 결정해서 호출 : 콜백함수는 고차함수에 의해 호출되며 고차함수는 필요에 따라 콜백함수에 인수를 전달 할 수 있다. 그래서 콜백함수를 호출하는게 아니라 함수 자체를 전달해야한다.

    ```js
    repeat(5, function (i) {
      if (i % 2) console.log(i);
    }); // 1 3
    ```

  - 이때 콜백함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다 > 콜백함수를 다른곳에서 호출하거나 자주 호출되면 함수 외부에서 콜백함수 정의 후 전달하는게 좋다.

    ```js
    const logOdds = function (i) {
      if (i % 2) console.log(i);
    };
    repeat(5, logOdds); //  콜백함수의 호출시점을 결정해서 호출하기 때문에 함수 자체 전달
    ```

  - 이러면 logOdds함수는 단 한번만 생성됨

- 순수 함수와 비순수 함수 :

  - 순수 함수 : 어떤 외부 상태에 의존하지도 않고 외부상태를 변경하지도 않는 즉 부수효과가 없는 함수

    ```js
    let count = 0;
    function plus(n) {
      return ++n;
    }

    plus(count); // 1
    console.log(count); // 0
    ```

    - 동일한 인수가 전달되면 언제나 동일한 값 반환
    - 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하여 반환값 생성
    - 함수의 외부 상태 변경 X

  - 비순수 함수 : 외부상태에 의존하거나 외부상태를 변경하는 즉 부수효과가 있는 함수

    ```js
    let count = 0;
    function plus() {
      return ++count;
    }

    plus(count); // 1
    console.log(count); // 1
    ```

    - 함수 내부에서 외부 상태를 직접 참조하지 않아도 매개변수를 통해 객체를 전달받으면 비순수함수가 된다. <br/>

- 지향해야하는 함수형 프로그래밍
  - 순수함수 + 보조함수를 통해서 부수효과를 최소화하여 불변성을 지향하는 지향
  - 로직내 조건문, 반복문을 제거해서 복잡성을 해결 (가독성때문)
  - 변수사용을 억제(누군가에 의해 언제든 변경되어 오류원인됨)
  - 생명주기를 최소화해서 상태변경을 피해 오류를 최소화

## 이야기해보고 싶은 내용

### p.156

> 함수는 객체 타입의 값이다.

반환값이 없는 함수는 값이 아니지 않나? undefined가 반환되어서 어찌됐든 값이 있는건가..?
=> 그냥 반환되는 값을 의미하는 것이 아닌 메모리에 저장될때 객체로 저장되니까 그래서 값이 있다라고 정리...

### p.157

> 표 12-1 에서 함수 몸체 설명의 부분의 <br/>
> "함수 호출시 일괄적으로 실행될 문을 실행단위로 정의한 코드 블록"

실행단위가 뭘까?

### p.159

> function add(x, y) {
> return x + y;
> }

함수 선언문은 표현식이 아니라서 콘솔에 찍으면 값이 안나온다고 했는데 add(1,3) 은 표현식이라서 나오는건가?

### p.177

> 함수 이름이 있는 기명 즉시 실행 함수도 사용할 수 있다. 하지만 그룹 연산자 내의 기명함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할수있는 식별자이므로 즉시 실행 함수를 다시 호출할 수 없다.

함수 리터럴로 평가되면 어떻게 되는데..? 바로 실행 후 재 호출 불가능해짐

```js
// 기명 즉시 실행함수
(function foo() {
  console.log("hi");
})(); // 1. 바로 hi 나옴

foo(); // 2. 다시 호출 시 ReferenceError
```

### p.184

> 예제 12-51

logAll, logOdds가 콜백함수, repaet이 고차함수가 되는걸까?
