# 핵심 내용 정리
- 원시 타입 : 변경 불가능한 값 - 실제 값 저장
    - 값에 의한 전달 : 원시값 복사
- 객체 타입 : 변경 가능한 값 - 참조 값 저장
    - 참조에 의한 전달 : 참조값 전달

## 11.1 원시값

- 변경 불가능한 값 (읽기 전용 값)
    - 데이터 신뢰성 보장
    - 변수 할당 시 실제 값이 저장
        - 새로운 메모리 공간 확보 후 재할당한 원시값 저장 그리고 참조 주소가 바뀌는것 
        ⇒ 불변성 : 원시값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 없음
    - 원시값을 갖는 변수를 다른 변수에 할당 시 값이 복사
    - 변수가 아니라 값이 변경 불가능하기 때문에 변수값은 교체 가능
    
    <aside>
    💡 상수 :  재할당이 금지된 변수 / 상수 ≠ 변경불가능한 값
    
    </aside>
    
- 문자열과 불변성
    - 타입별로 메모리공간 확보
    - 문자열은 0개 이상의 문자로 이루어진 집합 : 1개 문자 2바이트
    - 개발자의 편의를 위해 자바스크립트는 문자열 타입 제공
    - 문자열은 유사배열객체이자 이터러블
        - 유사배열객체 : 배열처럼 인덱스로 프로퍼티값 접근 가능, length 프로퍼티 있음
        - 그러나 아래와 같이 접근 시 문자열은 원시값이므로 변경 안됨
            - `str[0] = ‘S’ // 문자열은 원시값으로 변경X`
- 값에 의한 전달
    
    ```jsx
    var score = 80;
    var copy = score;
    
    console.log(score, copy) // 80,80
    
    score = 100
    
    console.log(score, copy) // 100,80
    ```
    
    - copy에는 score원시값이 복사되어 전달된다
    - score, copy의 값은 같지만 메모리공간은 다르다
    - 따라서 score값이 바껴도 copy에는 영향이 안 간다.
    - 값에 의한 전달 : 자바스크립트를 위한 용어는 아님
        - 변수에는 값이 전달되는것이 아닌 메모리 주소가 전달된다.  “변수는 O 값을 갖는다”
        - 식별자는 메모리주소에 붙인 이름 `var x = 10` 일 때 x는 메모리공간에 저장된 숫자 10을 식별할 수 있다.
    - `var copy = score;` : 두가지 평가방식이 있음
        - 새로운 80을 생성(복사)해서 메모리 주소를 전달하는 방식
        - score 변수값 80의 메모리 주소를 그대로 전달하는 방식. 할당시점에 두 변수가 기억하는 메모리 주소가 같다.
        
        ⇒ 값에 의한 전달도 사실은 값 전달이 아니라 메모리 주소 전달한다. 전달된 주소를 통해 메모리 공간에 접근하면 값 참조가 가능하다.
        
        ⇒ 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭 불가능하다.
        

## 11.2 객체

- 프로퍼티 개수가 정해져있지 않다.
- 동적 추가/삭제 가능
- 프로퍼티값도 제약 없다
- 메모리 공간의 크기를 사전에 정할 수 없다.

⇒ 원시값과는 다른 방식으로 동작한다.

- 자바스크립트 객체 관리 방식 : 프로퍼티키를 인덱스로 사용하는 해시테이블. 다른언어와 다르게 클래스 없이 객체 생성가능하고 객체 생성이후에도 동적으로 메서드 추가가 가능하다. 단 이런 특징은 비용이 더 많이 드는 비효율적인 방식이다. 따라서 히든클래스 방식을 사용하여 프로퍼티 접근 성능을 보장한다.

- 변경 가능한 값
    - 객체 타입의 값
    - 변수에 객체 할당 시 메모리 주소로 메모리 공간에 접근하면 참조 값에 접근한다.
        - 참조값 : 생성된 객체가 저장된 메모리 공간의 주소
    - 해당 참조값을 통해 실제 객체에 접근한다.
    
    ⇒ 변수는 객체를 참조하고 있다 즉 변수는 객체를 가리키고 있다.
    
    - 만약 원시값처럼 객체를 관리하면 메모리 효율적 소비가 어렵고 비용이 많이 들며 성능이 나쁘다. 따라서 지금과 같이 관리하는것이다.
        - 그러나 이경우 여러개의 식별자가 하나의 객체를 공유할 수 있다.
- 얕은 복사 & 깊은 복사 : 둘다 원본과 다른 객체
    - 얕은 복사 : 한 단계까지만 복사
        - `let b = {…a}`
            - a !== b
            - a.a  === b.a
    - 깊은 복사 “ 객체에 중첩되어 있는 객체까지 모두 복사
        - `b.cloneDeep(a)`
            - a !== b
            - a.a  !== b.a
    - 원시값 복사의 경우, </br>
![image](https://github.com/KingJiwon/js_deep_dive/assets/84695884/ab0746cd-10fd-41c5-b26b-d0d6ec5b2818)
- 참조에 의한 전달 :
    - 여러 식별자가 객체 공유 시 부작용
    
    ```jsx
    var = person = {
      name : 'Lee'
    }
    
    var copy = person // 얕은 복사 : 참조에 의한 전달
    ```
    
    - copy와 person은 메모리 주소는 다르지만 동일한 참조값을 갖음 : 두개의 식별자가 하나의 객체 공유
        - 프로퍼티 값 변경, 추가, 삭제 시 영향 O
    - 값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어있는 값을 복사해서 전달한다는 면에서 동일
    - 식별자가 기억하는 메모리공간의 값이 원시값인지 참조값인지 차이 ⇒ 자바스크립트에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다.
- 일치 비교 연산자 : === 타입을 변환하지 않고 비교함
    - 원시값에서 비교는 원시값을 비교하여 true
    - 참조값에서는 참조값을 비교하여 true
---

# 면접 예상 질문

## 불변성이란?
원시값을 할당한 변수는 재할당 이외에 변수값을 변경할 수 없는것을 의미합니다.


---

# 이야기하고 싶은 것


### p.138

> 상수는 재할당이 금지된 변수일 뿐이다.

생각해보지 못했던 내용이라 한번 떠들어보고 싶었습니닷

### p.144

> 그림 11-4, 11-5 

이해가.. 잘 안되여.. 두가지 관점에서 다 볼수있다는 것인지. 11-5는 파이썬에서만 동작하는 방식이라는것인지 헷갈림... 

