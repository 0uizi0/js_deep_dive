# 핵심 내용 정리

## **27.2 자바스크립트 배열은 배열이 아니다**

- 자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다.
- 즉, 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이를 **밀집 배열**이라 한다.
- 일반적인 의미의 배열은 각 요소가 동일한 데이터 크기를 가지며, 빈틈없이 연속적으로 이어져 있으므로 다음과 같이 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근(임의 접근, 시간 복잡도 O(1))할 수 있다. 이는 매우 효울적이며, 고속으로 동작한다.

```tsx
검색 대상 요소의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수
```

- 이처럼 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다.
- 하지만 정렬되지 않은 배열에서 특정한 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색(선형 검색, 시간 복잡도O(n))해야한다.
- 또한 배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점도 있다.

> **자바스크립트의 배열은 지금까지 살펴본 자료구조에서 말하는 일반적인 의미의 배열과 다르다**
> 
- 즉, 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 **희소 배열**이라 한다.
- 이처럼 자바스크립트의 배열은 엄밀히 말해 일반적 의미의 배열이 아니다. **자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.**

> **즉, 일반적인 배열과 비교한 자바스크립트 배열의 장점을 정리해보자면 다음과 같다.**
> 
- 자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우에는 상대적으로 느리다.
- 하지만 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.

## 27.3 length 프로퍼티와 희소 배열

- 희소 배열은 length와 배열 요소의 개수가 일치하지 않는다.
- 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.
- 희소 배열은 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않으며, 성능에도 좋지 않은 영향을 준다.
- 때문에 배열을 생성할 경우에는 희소 배열을 생성하지 않도록 주의하자.
- 배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.

## 27.8 배열 메서드

- 배열에는 원본 배열(배엘 메서드를 호출한 배열, 즉 배열 메서드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메서드와 직접 변경하지 않고 새로운 배열을 반환하는 메서드가 있다.
- 원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수 효과가 있으므로 사용할 때 주의해야 한다.
- 따라서 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋다.
- 원본 배열 변경 O : push,  pop, unshift, shift, splice, reverse
- 원본 배열 변경 X : concat, slice

### push와 unshift

- push와 unshift의 경우, 스프레드 문법을 사용해 원본 배열을 변경하지 않고 수행할 수 있다.
- 그러나 push/unshift 메서드와 concat 메서드를 사용하는 대신 ES6의 스프레드 문법을 일관성있게 사용하는 것을 권장한다.

### 얕은 복사, 깊은 복사

- slice 메서드를 사용해 생성된 복사본은 **얕은 복사**를 통해 생성된다.

> **얕은 복사** : 한 단계까지만 복사하는 것. slice 메서드, 스프레드 문법, Object.assign 메서드를 통해 수행한다.
> 

> **깊은 복사** : 객체에 중첩되어 있는 객체까지 모두 복사하는 것. Lodash 라이브러리의 cloneDeep 메서드를 사용한다.
> 

### flat 메서드

- 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.
- 중첩 배열을 평탄화할 깊이를 인수로 전달할 수 있으며, 인수를 생략할 경우 기본값은 1이다.
- 인수로 Infinity를 전달하면 중첩 배열 모두를 평탄화한다.

## 27.9 배열 고차 함수

- 고차 함수 : 함수를 인수로 전달받거나 함수를 반환하는 함수
- 고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 **불변성을 지향**하는 함수형 프로그래밍에 기반을 두고 있다.
- 함수형 프로그래밍 : 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 **조건문과 반복문을 제거**하여 복잡성을 해결하고 **변수의 사용을 억제**하여 상태 변경을 피하려는 프로그래밍 패러다임이다.
- 결국 **순수 함수를 통해 부수 효과를 최대한 억제**하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이다.

### forEach

- for 문을 대체할 수 있는 고차 함수
- 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출한다.
- forEach 메서는 원본 배열을 변경하지 않는다. 하지만 콜백 함수를 통해 원본 배열을 변경할 수는 있다.
- for문과 달리 break, continue문을 사용할 수 없다. 다시 말해, 배열의 모든 요소를 빠짐없이 순회하며 중간에 순회를 중단할 수 없다.

### map

- 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다.
- 그리고 **콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다**
- 이때 원본 배열은 변경되지 않는다
- **map 메서드가 생성하여 반환하는 새로운 배열의 length 프로퍼티 값은 map 메서드를 호출한 배열의 length 프로퍼티 값과 반드시 일치한다. 즉, map 메서드를 호출한 배열과 map 메서드가 생성하여 반환한 배열은 1:1 매핑한다.**

### reduce

- reduce 메서드는 자신을 호출한 배열을 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출한다.
- 그리고 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 **하나의 결과값을 만들어 반환한다**.
- 이때 원본 배열은 변경되지 않는다.
- reduce 메서드는 첫 번째 인수로 콜백 함수, 두 번쨰 인수로 초기값을 전달받는다.
- reduce 메서드의 콜백 함수에는 4개의 인수, 초기값 또는 콜백 함수의 이전 반환값, reduce 메서드를 호출한 배열의 요소값과 인덱스, 호출한 배열 자체(this)가 전달된다.
- reduce 메서드는 초기값과 배열의 첫 번째 요소값을 콜백 함수에게 인수로 전달하면서 호출하고 다음 순회에는 콜백 함수의 반환값과 두 번째 요소값을 콜백 함수의 인수로 전달하면서 호출한다.
- 이러한 과정을 반복하여 **reduce 메서드는 하나의 결과값을 반환한다**
- map, filter, some, every, find 같은 모든 배열의 고차 함수는 reduce 메서드로 구할 수 있다.

### flatMap

- map 메서드를 통해 생성된 새로운 배열을 평탄화한다.
- 즉 map 메서드와 flat 메서드를 순차적으로 실행하는 효과가 있다.
- 단, flatMap 메서드는 flat 메서드처럼 인수를 전달하여 평탄화 깊이를 지정할 수는 없고 1단계만 평탄화한다. 중첩 배열의 평탄화 깊이를 지정해야 한다면 map과 flat을 각각 호출해야 한다.

```tsx
const arr = ["hello", "wolrd"];

// flatMap은 1단계만 평탄화 한다.
arr.flatMap((str, index) => [index, [str, str.length]]);
// [[0, ['hello', 5]], [1, ['world, 5]]] => [0, ['hello', 5], 1, ['world, 5]]
// map과 flat 각각 호출
arr.map((str, index) => [index, [str, str.length]]).flat(2);
// [[0, ['hello', 5]], [1, ['world, 5]]] => [0, 'hello', 5, 1, 'world', 5]
```

---

# 면접 예상 질문

## **💥 희소 배열이란?**

배열의 요소가 연속적으로 이어져 있지 않고 일부가 비어 있는 배열

## **💥 일반적인 배열과 비교한 자바스크립트 배열의 장점은?**

자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우에는 상대적으로 느리다.

하지만 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.

## **💥 스택과 큐의 차이**

- 스택 : 후입선출(LIFO - Last In First Out) 방식의 자료 구조
- 큐 : 선입선출(FIFO - First In First Out) 방식의 자료 구조

## **💥 push, unshift와 concat의 차이**

- push와 unshift 메서드는 원본 배열을 직접 변경하지만 concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
- 따라서 push와 unshift 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해두어야 하며 concat 메서드를 사용할 경우 반환값을 반드시 변수에 할당받아야한다.

## **💥 얕은 복사와 깊은 복사**

- 얕은 복사 : 한 단계까지만 복사하는 것. slice 메서드, 스프레드 문법, Object.assign 메서드를 통해 수행한다.
- 깊은 복사 : 객체에 중첩되어 있는 객체까지 모두 복사하는 것. Lodash 라이브러리의 cloneDeep 메서드를 사용한다.

## **💥 forEach와 map의 차이**

> 공통점 : 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다.
> 
- forEach 메서드 : 단순히 **반복문을 대체**하기 위한 고차 함수
- map 메서드 : 요소값을 다른 값으로 매핑한 **새로운 배열을 생성**하기 위한 고차 함수

---

# 이야기하고 싶은 것

