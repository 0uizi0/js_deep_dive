# 핵심 내용 정리

- `연산자` : 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.
- `피연산자` : 연산의 대상, 값으로 평가될 수 있는 표현식

## 7.1 산술 연산자

- `산술 연산자` : 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
- 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분한다.

### 7.1.1 이항 산술 연산자

<img width="513" alt="스크린샷 2024-01-15 오후 4 38 16" src="https://github.com/KingJiwon/js_deep_dive/assets/102431281/6d62d521-a901-40d7-addc-ef6f9b94ec7e">

- **2개의 피연산자**를 산술 연산하여 숫자 값을 만든다.
- 피연산자의 값을 변경하는 **부수 효과**가 없다.

### 7.1.2 단항 산술 연산자

<img width="540" alt="스크린샷 2024-01-15 오후 4 38 50" src="https://github.com/KingJiwon/js_deep_dive/assets/102431281/84783b48-71cf-4656-8cf3-3d544f5f433d">

- **1개의 피연산자**를 산술 연산하여 숫자 값을 만든다.
- **증가/감소 연산자(`++`, `--`)는** 피연산자의 값을 변경하는 **부수효과가 있다.**
    
    ⇒ 피연산자의 값을 변경하는 암묵적 할당이 이뤄짐
    

### 7.1.3 문자열 연결 연산자

- + 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 작동한다.
    
    ```jsx
    1 + true // 1 + 1 = 2, 2 반환
    ```
    
    ⇒ **암묵적 타입 변환, 타입 강제 변환**
    

## 7.2 할당 연산자

- 우항에 있는 피연산자의 평과 결과를 좌항에 있는 변수에 할당한다.
- `=`, `+=`, `-=`, `*=`, `/=`, `%=`
- 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.
    
    ```jsx
    var a, b, c;
    
    a = b = c = 0
    // 연쇄 할당. 오른쪽에서 왼쪽으로 진행
    // c = 0 -> b = 0 -> a = 0
    
    console.log(a, b, c); // 0 0 0
    ```
    

## 7.3 비교 연산자

- `비교 연산자` : 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

### 7.3.1 동등/일치 비교 연산자

- 동등/일치 비교 연산자 : 좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.
    - `동등 비교(==) 연산자` : 좌항과 우항의 피연산자를 비교할 때 먼저 **암묵적 타입 변환**을 통해 타입을 일치시킨 후 같은 값인지 비교한다.
        
        ⇒ 느슨한 비교 ⇒ 예측하기 어려운 결과를 만들어냄 ⇒ 권장 X
        
    - `일치 비교(===) 연산자` : 좌항과 우항의 피연산자가 **타입이 같고 값도 같은 경우**에 한하여 true를 반환한다.
        
        ⇒ 엄격한 비교
        
        → **BUT** -0 과 +0 비교 시 true를 반환함.
        

⇒ **Object.is 메서드** : 예측 가능한 정확한 비교 결과 반환

→ -0 과 +0 비교 시 false를 반환함.

## 7.4 삼항 조건 연산자

- `조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값`
- **삼항 조건 연산자는 값처럼 사용**할 수 있지만 if-else문은 값처럼 사용할 수 없다.

## 7.7 그룹 연산자

- 소괄호(`()`)로 피연산자를 감싸 자신의 피연산자인 표현식을 가장 먼저 평가한다.
    
    ⇒ 연산자의 우선순위 조절 가능
    

## 7.8 typeof 연산자

- 피연산자의 데이터 타입을 문자열로 반환한다.
- `typeof null`의 경우 null이 아닌 object를 반환한다.
    
    ⇒ 값이 null인지 확인할 때는 일치 연산자(===) 사용하기!
    

## 7.9 지수 연산자

- 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값을 반환한다.
- Math.pow 메서드보다 가독성이 좋다.
- 이항 연산자 중에서 우선순위가 가장 높다.
    - `연산자 우선순위` : 여러 개의 연산자로 이뤄진 문이 실행될 때 연산자가 실행되는 순서
    - `연산자 결합순서` : 연산자의 어느쪽(좌항 or 우항)부터 평가를 수행할 것인지를 나타내는 순서

## 7.11 연산자의 부수효과

- 대부분의 연산자는 부수효과가 없지만, 일부 연산자(할당 연산자 `=`, 증가`++`/감소`--` 연산자, delete 연산자)는 부수효과가 있다.

---

# 면접 예상 질문

## 💥 부수효과란?

외부에서 받아온 데이터를 직접적으로 변경하는 것을 말한다.

외부 데이터 변경으로 인해 예측 불가능한 버그가 발생할 수 있고, 코드의 유지보수가 어려워지기 때문에 부수효과 사용을 최대한 지양해야합니다.

## 💥 부수효과를 피해야 하는 이유?

부수 효과가 있는 함수의 경우, 외부 데이터에 영향을 받기 때문에 실행 시점이나 횟수에 의존한다.

그러나 부수 효과가 없는 함수, 즉 계산의 경우에는 같은 입력값을 주면 항상 같은 출력값이 나오기 때문에 테스트가 용이하며 재사용 및 유지보수하기가 쉽다.

때문에, 오류를 피하고 프로그램의 안정성을 높이기 위해 부수효과를 피해야한다.

## 💥 부수효과를 피하기 위한 방법?

부수 효과를 피하기 위해서는 액션 함수를 계산 함수로 변경해야하는데, 이 때 사용할 수 있는 대표적인 방식 중 하나가 ‘카피-온-라이트’이다.

카피-온-라이트는 데이터의 복사본을 만들고, 복사본을 변경한 후, 복사본을 리턴하는 간단한 방법이지만, 외부 데이터를 건드리지 않아 오류 가능성을 낮춘다.

또한 함수 내에 있는 암묵적 입력을 찾아 인자로 바꾸고, 암묵적 출력의 경우 리턴값으로 변경하는 방법도 있다.

## 💥 부수효과를 개선한 경험이 있나요?

실제로 JS 스터디 구현 과제 중, 카운터를 구현할 때 음수, 0, 양수에 따른 클래스값을 지정하는 함수에서 암묵적 입력을 발견해, 암묵적 입력을 인자로 바꾸는 리팩토링을 진행한 경험이 있습니다.

```jsx
/** 음수, 0, 양수에 따른 클래스 값 지정(리팩터링 전) */
const changeColor = (num) => {
  if (num === 0) return (value.className = "zero");
  else if (num < 0) return (value.className = "negative");
  else return (value.className = "positive");
};

/** 음수, 0, 양수에 따른 클래스 값 지정(리팩터링 후) */
const changeColor = (num, value) => {
  if (num === 0) return (value.className = "zero");
  else if (num < 0) return (value.className = "negative");
  else return (value.className = "positive");
};
```

---

# 이야기하고 싶은 것

### p.80

> 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.
> 
> 
> ```jsx
> var a, b, c;
> 
> a = b = c = 0
> // 연쇄 할당. 오른쪽에서 왼쪽으로 진행
> // c = 0 -> b = 0 -> a = 0
> 
> console.log(a, b, c); // 0 0 0
> ```
> 

5장을 읽으면서 [콘솔창에 var foo = x = 100 입력시 undefined 출력되는 이유](https://github.com/KingJiwon/js_deep_dive/issues/4)에 대해 함께 이야기를 나눌 때, foo와 x가 선언되는 진행 단계가 급 궁금했었는데 여기서 해소가 되네요~~